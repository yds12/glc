use rand::prelude::*;

/// Represents a context-free grammar. Contains a [`NonTerminal`] which
/// represents the starting symbol and a list of [`Rule`]s.
#[derive(Debug, Clone)]
pub struct Grammar(pub NonTerminal, pub Vec<Rule>);

/// Represents a grammar rule. Contains a [`NonTerminal`] which represents the
/// rule's head, and a [`RuleBody`].
#[derive(Debug, Clone)]
pub struct Rule(pub NonTerminal, pub RuleBody);

/// The body of a rule. The body can be just a [`Sequence`] (of symbols) or an
/// [`Or`]. The latter is equivalent to a set of rules with the same head, each
/// with a sequence as the body.
///
/// When a rule is applied, a [`NonTerminal`] [`Symbol`] is replaced with the
/// [`RuleBody`]. If the body is an [`Or`], one of the sequences of the `Or`
/// has to be chosen.
#[derive(Debug, Clone)]
pub enum RuleBody {
    Or(Or),
    Sequence(Sequence),
}

/// A disjunction of [`Sequence`]s.
#[derive(Debug, Clone)]
pub struct Or(pub Vec<Sequence>);

/// A sequence of [`Symbol`]s.
#[derive(Debug, Clone)]
pub struct Sequence(pub Vec<Symbol>);

/// A [`Symbol`] can be a [`Terminal`] (a symbol that can appear in the final
/// expression generated by the grammar) or a [`NonTerminal`] (a symbol that
/// must be replaced further).
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Symbol {
    NonTerminal(NonTerminal),
    Terminal(Terminal),
}

/// A non-terminal symbol is a symbol that must be replaced further before the
/// final expression is complete.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct NonTerminal(pub String);

/// A terminal symbol is a symbol that is not further replaceable. It can
/// appear in the final expression generated.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Terminal(pub String);

/// A derivation starts with the starting non-terminal symbol of the grammar and
/// progresses by iteratively replacing non-terminals by some sequence of
/// symbols, according to the grammar rules.
///
/// The second parameter of type `usize` is the index of the last terminal
/// symbol (used to improve performance).
#[derive(Debug, Clone)]
pub struct Derivation(pub Vec<Symbol>, pub usize);

/// An expression constituted of a sequence of terminal symbols. These
/// expressions can be obtained by making a complete [`Derivation`] with the
/// [`Grammar`]. A [`Derivation`] that has only terminal symbols can be
/// converted into an expression.
#[derive(Debug, Clone)]
pub struct Expression(pub Vec<Terminal>);

/// Represents a disjunctive rule: a non-terminal that can be replaced by one of
/// the listed terminal symbols. An invocation of this macro looks like this:
///
///     # use glc::t_or_rule;
///     # fn main() { let _ =
///     t_or_rule!("A" => "a", "b")
///     # ; }
///
/// In the case above we have a non-terminal symbol "A" that can be replaced by
/// either "a" or "b" (both terminals). Note that you can have any number of
/// elements after the `=>`.
#[macro_export]
macro_rules! t_or_rule {
    ($nt:expr => $( $string:expr ),*) => {
        $crate::Rule($crate::NonTerminal($nt.into()),
        $crate::RuleBody::Or($crate::Or(vec![
            $(
                $crate::Sequence(vec![$crate::Symbol::Terminal($crate::Terminal($string.into()))])
            ),*
        ])))
    };
}


/// Represents a rule that replaces one non-terminal by a sequence of
/// non-terminals. Invoke it like this:
///
///     # use glc::nt_seq_rule;
///     # fn main() { let _ =
///     nt_seq_rule!("A" => "B", "C")
///     # ; }
///
/// In the case above, a non-terminal "A" would be replaced by the sequence of
/// non-terminals "B" "C". Note that you can have any number of elements after
/// the `=>`.
#[macro_export]
macro_rules! nt_seq_rule {
    ($nt:expr => $( $string:expr ),*) => {
        $crate::Rule($crate::NonTerminal($nt.into()),
        $crate::RuleBody::Sequence($crate::Sequence(vec![
            $(
                $crate::Symbol::NonTerminal($crate::NonTerminal($string.into()))
            ),*
        ])))
    };
}

/// Generate a non-terminal symbol from a string.
///
/// A `nt!("A")` is equivalent to `NonTerminal("A".into())`.
#[macro_export]
macro_rules! nt {
    ($string:expr) => {
        $crate::NonTerminal($string.into())
    };
}

impl Grammar {
    /// Generate a random expression using the grammar
    pub fn gen(&self) -> String {
        let d = self.start_derivation();
        let expr = d.derive(&self);
        expr.to_string()
    }

    /// Start a [`Derivation`] based on this grammar. It will initially only
    /// have the starting [`Symbol`].
    pub fn start_derivation(&self) -> Derivation {
        Derivation(vec![Symbol::NonTerminal(self.0.clone())], 0)
    }

    fn choose_rule(&self, nt: NonTerminal) -> &Rule {
        let mut rules = Vec::new();

        for rule in self.1.iter() {
            if rule.0 == nt {
                rules.push(rule);
            }
        }

        rules.shuffle(&mut rand::thread_rng());
        rules.iter().next().unwrap_or_else(||
            panic!("no rule for {nt:?}")
        )
    }
}

impl Derivation {
    /// Apply rules until this [`Derivation`] is complete, and return the
    /// finished [`Expression`].
    pub fn derive(mut self, grammar: &Grammar) -> Expression {
        while !self.is_done() {
            self.derive_step(grammar);
        }

        self.into()
    }

    /// Apply one rule to the [`Derivation`] (if it is not finished).
    pub fn derive_step(&mut self, grammar: &Grammar) {
        if self.is_done() {
            return;
        }

        let nt = self.find_nt();

        if let Some(nt) = nt {
            let rule = grammar.choose_rule(nt);
            self.apply(rule);
        }
    }

    /// Check if the [`Derivation`] is complete, i.e. it has no [`NonTerminal`]
    /// [`Symbol`]s, only [`Terminal`]s.
    pub fn is_done(&self) -> bool {
        for symbol in &self.0[self.1..] {
            if let Symbol::NonTerminal(_) = symbol {
                return false;
            }
        }

        true
    }

    fn find_nt(&self) -> Option<NonTerminal> {
        for symbol in &self.0[self.1..] {
            if let Symbol::NonTerminal(nt) = symbol {
                return Some(nt.clone());
            }
        }

        None
    }

    fn find(&self, nt: &NonTerminal) -> Option<usize> {
        for (i, elem) in self.0.iter().enumerate() {
            if let Symbol::NonTerminal(el) = elem {
                if el == nt {
                    return Some(i);
                }
            }
        }

        None
    }

    fn apply(&mut self, rule: &Rule) {
        match self.find(&rule.0) {
            Some(index) => self.apply_at(rule, index),
            None => panic!("rule cannot be applied")
        }
    }

    fn apply_at(&mut self, rule: &Rule, index: usize) {
        let seq = match &rule.1 {
            RuleBody::Sequence(seq) => {
                seq.0.clone()
            }
            RuleBody::Or(or) => {
                or.choose_seq().0.clone()
            }
        };

        self.1 = index;
        self.0.splice(index..(index + 1), seq);
    }
}

impl From<Derivation> for Expression {
    fn from(d: Derivation) -> Self {
        Self(d.0.into_iter().map(|sym| match sym {
            Symbol::NonTerminal(_) => panic!("derivation is not complete"),
            Symbol::Terminal(t) => t
        }).collect())
    }
}

impl std::fmt::Display for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        for t in &self.0 {
            write!(f, "{}", t.0)?;
        }

        Ok(())
    }
}

impl std::fmt::Display for Derivation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        for t in &self.0 {
            match t {
                Symbol::NonTerminal(s) => write!(f, "{}", s.0)?,
                Symbol::Terminal(s) => write!(f, "{}", s.0)?,
            }
        }

        Ok(())
    }
}

impl Or {
    fn choose_seq(&self) -> &Sequence {
        if self.0.is_empty() {
            panic!("empty or");
        }

        let rand_index = rand::thread_rng().gen_range(0..self.0.len());
        &self.0[rand_index]
    }
}

#[cfg(test)]
mod tests {
    use crate::{Grammar, nt, nt_seq_rule, t_or_rule};

    fn build_grammar() -> Grammar {
        Grammar(
            nt!("S"),
            vec![
                nt_seq_rule!("S" => "A", "N"),
                t_or_rule!("A" => "a"),
                t_or_rule!("N" => "0"),
            ],
        )
    }

    #[test]
    fn it_works() {
        let grammar = build_grammar();
        assert_eq!(grammar.gen(), "a0");
    }
}
